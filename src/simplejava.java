/* Generated By:JavaCC: Do not edit this line. simplejava.java */
public class simplejava implements simplejavaConstants {

  static final public ASTProgram program() throws ParseException {
    ASTProgram aP = new ASTProgram(null, null, 0);
    ASTFunctionDefinitions functionDefs = new ASTFunctionDefinitions();
    ASTClasses classes = new ASTClasses();
    classes = classDefs();
    functionDefs = funcDecs();
    jj_consume_token(0);
      /* The program was parsed */
      aP.setclasses(classes);
      aP.setfunctiondefinitions(functionDefs);
      {if (true) return aP;}
    throw new Error("Missing return statement in function");
  }

// this should return ASTClasses
  static final public ASTClasses classDefs() throws ParseException {
    ASTClasses classes = new ASTClasses();
    ASTClass astClass;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      astClass = classDef();
            classes.addElement(astClass);
    }
        {if (true) return classes;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTFunctionDefinitions funcDecs() throws ParseException {
    ASTFunctionDefinitions functionDefs = new ASTFunctionDefinitions();
    ASTFunctionDefinition functionDef;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      functionDef = funcDec();
            /* A function was parsed */
            functionDefs.addElement(functionDef);
    }
        /* All Functions have been parsed */
        {if (true) return functionDefs;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTClass classDef() throws ParseException {
    ASTClass astClass;
    ASTInstanceVariableDefs variableDefs = new ASTInstanceVariableDefs();
    ASTInstanceVariableDef variableDef;
    Token name;
    jj_consume_token(CLASS);
    name = jj_consume_token(IDENTIFIER);
    jj_consume_token(LEFTBRACE);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
      variableDef = classVariableDef();
            variableDefs.addElement(variableDef);
    }
    jj_consume_token(RIGHTBRACE);
        astClass = new ASTClass(name.toString(), variableDefs, name.beginLine);
        {if (true) return astClass;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTFunctionDefinition funcDec() throws ParseException {
    Token type, name;
    ASTFormals formals;
    ASTStatement statement;
    ASTStatements statements = new ASTStatements();
    type = jj_consume_token(IDENTIFIER);
    name = jj_consume_token(IDENTIFIER);
    formals = formalParamList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
            /* Function Prototype STATUS: DONE */
            {if (true) return new ASTPrototype(type.toString(),  name.toString(), formals, type.beginLine);}
      break;
    case LEFTBRACE:
      jj_consume_token(LEFTBRACE);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FOR:
        case IF:
        case WHILE:
        case DO:
        case RETURN:
        case LEFTBRACE:
        case SEMICOLON:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_4;
        }
        statement = statement();
                statements.addElement(statement);
      }
      jj_consume_token(RIGHTBRACE);
            /* Function Definition STATUS: NOTDONE */
            {if (true) return new ASTFunction(type.toString(),  name.toString(), formals, statements, type.beginLine);}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTFormals formalParamList() throws ParseException {
                               ASTFormals formals = new ASTFormals(); ASTFormal formal; Token type, name; int dimCount;
    jj_consume_token(LEFTPARAN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      type = jj_consume_token(IDENTIFIER);
      name = jj_consume_token(IDENTIFIER);
      dimCount = arrayDimDec();
                      formals.addElement(new ASTFormal(type.toString(), name.toString(), dimCount, type.beginLine));
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_5;
        }
        jj_consume_token(COMMA);
        type = jj_consume_token(IDENTIFIER);
        name = jj_consume_token(IDENTIFIER);
        dimCount = arrayDimDec();
                          formals.addElement(new ASTFormal(type.toString(), name.toString(), dimCount, type.beginLine));
      }
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(RIGHTPARAN);
      {if (true) return formals;}
    throw new Error("Missing return statement in function");
  }

  static final public void informalParamList() throws ParseException {
    jj_consume_token(LEFTPARAN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case NEW:
    case MINUS:
    case NOT:
    case LEFTPARAN:
    case SINGLEQUOTE:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      expression();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_6;
        }
        jj_consume_token(COMMA);
        expression();
      }
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(RIGHTPARAN);
  }

  static final public int arrayDimDec() throws ParseException {
                     int dimCount = 0;
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACKET:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_7;
      }
      jj_consume_token(LEFTBRACKET);
      jj_consume_token(RIGHTBRACKET);
                                   dimCount++;
    }
     {if (true) return dimCount;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTInstanceVariableDef classVariableDef() throws ParseException {
    ASTInstanceVariableDef instanceVar;
    Token type, name;
    int arrayDim;
    type = jj_consume_token(IDENTIFIER);
    name = jj_consume_token(IDENTIFIER);
    arrayDim = arrayDimDec();
    jj_consume_token(SEMICOLON);
        instanceVar = new ASTInstanceVariableDef(type.toString(), name.toString(), arrayDim, type.beginLine);
        {if (true) return instanceVar;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement statement() throws ParseException {
    ASTStatement resultingStatement = null;
    Token lineToken;
    boolean flag = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTBRACE:
      resultingStatement = blockStatement();
      break;
    case IF:
      resultingStatement = ifStatement();
      break;
    case WHILE:
      resultingStatement = whileStatement();
      break;
    case FOR:
      resultingStatement = forStatement();
      break;
    case DO:
      resultingStatement = doWhileStatement();
      break;
    case RETURN:
    case SEMICOLON:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RETURN:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          resultingStatement = identifierPrefix();
          break;
        case RETURN:
          resultingStatement = returnStatement();
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                    flag = true;
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      lineToken = jj_consume_token(SEMICOLON);
                if(flag == false) {
                    resultingStatement = new ASTEmptyStatement(lineToken.beginLine);
                }
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return resultingStatement;}
    throw new Error("Missing return statement in function");
  }

/* Parses the what I'm calling the "property accessors" 
 * These are either an array bracket indexer or a class dot operator.
 * These can follow a base variable.           
 */
  static final public ASTVariable propertyAccessors(ASTVariable base) throws ParseException {
    ASTExpression indexExp;
    Token member;
    ASTVariable returnVar = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTBRACKET:
      indexExp = arrayDimWithExpression();
                /* parsed an array variable */
                ASTArrayVariable childArrayVar = new ASTArrayVariable(base, indexExp, base.line());
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACKET:
      case DOT:
        returnVar = propertyAccessors(childArrayVar);
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
                if(returnVar == null) {
                    {if (true) return childArrayVar;}
                } else {
                    {if (true) return returnVar;}
                }
      break;
    case DOT:
      jj_consume_token(DOT);
      member = jj_consume_token(IDENTIFIER);
                /* class dot operator */
                ASTClassVariable childClassVar = new ASTClassVariable(base, member.toString(), member.beginLine);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACKET:
      case DOT:
        returnVar = propertyAccessors(childClassVar);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
                if(returnVar == null) {
                    {if (true) return childClassVar;}
                } else {
                    {if (true) return returnVar;}
                }
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement identifierPrefix() throws ParseException {
    Token type, name;
    ASTExpression exp = null;
    int arrayDecDim = 0;
    ASTVariable baseVar;
    ASTAssignmentStatement assignmentStatement;
    ASTFunctionCallStatement funcCallStatement;
    type = jj_consume_token(IDENTIFIER);
        // initialize baseVar for propertAccessor recursion
        baseVar = new ASTBaseVariable(type.toString(), type.beginLine);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case LEFTBRACKET:
    case DOT:
    case GETS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACKET:
      case DOT:
        baseVar = propertyAccessors(baseVar);
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GETS:
        jj_consume_token(GETS);
        exp = expression();
                        /* An assignment statement was parsed */
                        {if (true) return new ASTAssignmentStatement(baseVar,exp,type.beginLine);}
        break;
      case PLUS:
      case MINUS:
        assignmentStatement = incrementShortSuffix(baseVar);
                    /* A short hand increment suffix was parsed */
                    {if (true) return assignmentStatement;}
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      arrayDecDim = arrayDimDec();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GETS:
        jj_consume_token(GETS);
        exp = expression();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
            /* Variable declaration statement */
            ASTVariableDefStatement varDefStatement;

            if(exp == null) {
                varDefStatement = new ASTVariableDefStatement(type.toString(), name.toString(), arrayDecDim, type.beginLine);
            } else {
                varDefStatement = new ASTVariableDefStatement(type.toString(), name.toString(), arrayDecDim, exp, type.beginLine);
            }

            {if (true) return varDefStatement;}
      break;
    case LEFTPARAN:
      jj_consume_token(LEFTPARAN);
                funcCallStatement = new ASTFunctionCallStatement(type.toString(), type.beginLine);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
      case NEW:
      case MINUS:
      case NOT:
      case LEFTPARAN:
      case SINGLEQUOTE:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        exp = expression();
                    funcCallStatement.addElement(exp);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[19] = jj_gen;
            break label_8;
          }
          jj_consume_token(COMMA);
          exp = expression();
                        funcCallStatement.addElement(exp);
        }
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      jj_consume_token(RIGHTPARAN);
                {if (true) return funcCallStatement;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTAssignmentStatement incrementShortSuffix(ASTVariable base) throws ParseException {
    ASTAssignmentStatement assignmentStatement;
    ASTIntegerLiteral one;
    ASTExpression left;
    ASTExpression right;
    Token lineStart;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      lineStart = jj_consume_token(PLUS);
      jj_consume_token(PLUS);
            one = new ASTIntegerLiteral(1, lineStart.beginLine);
            left = new ASTVariableExpression(base, base.line());
            right = new ASTOperatorExpression(left, one, ASTOperatorExpression.PLUS, lineStart.beginLine);
            assignmentStatement = new ASTAssignmentStatement(base, right, lineStart.beginLine);
            {if (true) return assignmentStatement;}
      break;
    case MINUS:
      lineStart = jj_consume_token(MINUS);
      jj_consume_token(MINUS);
            one = new ASTIntegerLiteral(1, lineStart.beginLine);
            left = new ASTVariableExpression(base, base.line());
            right = new ASTOperatorExpression(left, one, ASTOperatorExpression.MINUS, lineStart.beginLine);
            assignmentStatement = new ASTAssignmentStatement(base, right, lineStart.beginLine);
            {if (true) return assignmentStatement;}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement blockStatement() throws ParseException {
    ASTStatements statements = new ASTStatements();
    ASTStatement statement = null;
    jj_consume_token(LEFTBRACE);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FOR:
      case IF:
      case WHILE:
      case DO:
      case RETURN:
      case LEFTBRACE:
      case SEMICOLON:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_9;
      }
      statement = statement();
            statements.addElement(statement);
    }
    jj_consume_token(RIGHTBRACE);
        {if (true) return statements;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression arrayDimWithExpression() throws ParseException {
    ASTExpression elem = null;
    jj_consume_token(LEFTBRACKET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case NEW:
    case MINUS:
    case NOT:
    case LEFTPARAN:
    case SINGLEQUOTE:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      elem = expression();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    jj_consume_token(RIGHTBRACKET);
        // what should the expression index be if the brackets are empty?
        // is that even possible syntacticly?
        {if (true) return elem;}
    throw new Error("Missing return statement in function");
  }

// XXX: Dangling else warning!
  static final public ASTIfStatement ifStatement() throws ParseException {
    ASTExpression test;
    ASTStatement thenstatement = null, elsestatement = null;
    Token ifToken;
    ifToken = jj_consume_token(IF);
    jj_consume_token(LEFTPARAN);
    test = expression();
    jj_consume_token(RIGHTPARAN);
    thenstatement = statement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      elsestatement = statement();
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
        {if (true) return new ASTIfStatement(test, thenstatement, elsestatement, ifToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement whileStatement() throws ParseException {
    ASTExpression test;
    ASTStatement body;
    Token tokenLine;
    tokenLine = jj_consume_token(WHILE);
    jj_consume_token(LEFTPARAN);
    test = expression();
    jj_consume_token(RIGHTPARAN);
    body = statement();
        {if (true) return new ASTWhileStatement(test, body, tokenLine.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement forStatement() throws ParseException {
    ASTStatement initialize = null;
    ASTExpression test = null;
    ASTStatement increment = null;
    ASTStatement body = null;
    Token lineToken;
    lineToken = jj_consume_token(FOR);
    jj_consume_token(LEFTPARAN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      initialize = identifierPrefix();
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
    test = expression();
    jj_consume_token(SEMICOLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      increment = identifierPrefix();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(RIGHTPARAN);
    body = statement();
        {if (true) return new ASTForStatement(initialize, test, increment, body, lineToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTDoWhileStatement doWhileStatement() throws ParseException {
    ASTExpression test = null;
    ASTStatement body = null;
    Token tokenLine;
    tokenLine = jj_consume_token(DO);
    body = statement();
    jj_consume_token(WHILE);
    jj_consume_token(LEFTPARAN);
    test = expression();
    jj_consume_token(RIGHTPARAN);
        {if (true) return new ASTDoWhileStatement(test, body, tokenLine.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTReturnStatement returnStatement() throws ParseException {
    ASTExpression exp = null;
    Token lineToken = null;
    lineToken = jj_consume_token(RETURN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case NEW:
    case MINUS:
    case NOT:
    case LEFTPARAN:
    case SINGLEQUOTE:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      exp = expression();
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
        {if (true) return new ASTReturnStatement(exp, lineToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expression() throws ParseException {
    Token type;
    ASTExpression resultingExpression;
    int arrayDimCount = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NEW:
      jj_consume_token(NEW);
      type = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACKET:
        resultingExpression = arrayDimWithExpression();
                    arrayDimCount++;
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LEFTBRACKET:
            ;
            break;
          default:
            jj_la1[29] = jj_gen;
            break label_10;
          }
          arrayDimWithExpression();
                        arrayDimCount++;
        }
                    /* Allocating an array */
                    {if (true) return new ASTNewArrayExpression(type.toString(), resultingExpression, arrayDimCount, type.beginLine);}
        break;
      case LEFTPARAN:
        informalParamList();
                    /* Instantiating class */
                     {if (true) return new ASTNewClassExpression(type.toString(), type.beginLine);}
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case TRUE:
    case FALSE:
    case MINUS:
    case NOT:
    case LEFTPARAN:
    case SINGLEQUOTE:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      /* The expression did not start with the new statement. 
               * The possible parse paths are contained in expNoNew().        
               */
              resultingExpression = expNoNew();
            {if (true) return resultingExpression;}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* All expresions that do not start with the <NEW> */
  static final public ASTExpression expNoNew() throws ParseException {
    ASTExpression resultingExpression = null;
    // resultingExpression = expNoNewParans()
            // |  
            // resultingExpression = expNoNewNoParans()
            resultingExpression = expressionTopTopCHILL();
        {if (true) return resultingExpression;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expNoNewParans() throws ParseException {
    jj_consume_token(LEFTPARAN);
    expressionVarOrConstant();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case MULTIPLY:
    case DIVIDE:
    case EQUAL:
    case GREATERTHAN:
    case NOT:
    case GREATEROREQUAL:
    case AND:
    case NOTEQUAL:
    case LESSOREQUAL:
    case LESSTHAN:
    case OR:
      expressionOperator();
      expNoNew();
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    jj_consume_token(RIGHTPARAN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case MULTIPLY:
    case DIVIDE:
    case EQUAL:
    case GREATERTHAN:
    case NOT:
    case GREATEROREQUAL:
    case AND:
    case NOTEQUAL:
    case LESSOREQUAL:
    case LESSTHAN:
    case OR:
      expressionOperator();
      expNoNew();
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expressionTopTopCHILL() throws ParseException {
    ASTExpression left = null;
    ASTExpression right = null;

    Token operatorToken = null;
    left = expressionTopCHILL();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
      case OR:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        operatorToken = jj_consume_token(OR);
        break;
      case AND:
        operatorToken = jj_consume_token(AND);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = expressionTopCHILL();
            // create operation expression from left and right
            ASTOperatorExpression newOpExp = new ASTOperatorExpression(left, right, operatorToken.toString(), operatorToken.beginLine);
            // set left to be the new operation expression          
            left = newOpExp;
    }
        {if (true) return left;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expressionTopCHILL() throws ParseException {
    ASTExpression left = null;
    ASTExpression right = null;

    Token operatorToken = null;
    left = expressionCHILL();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATERTHAN:
      case GREATEROREQUAL:
      case NOTEQUAL:
      case LESSOREQUAL:
      case LESSTHAN:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESSTHAN:
        operatorToken = jj_consume_token(LESSTHAN);
        break;
      case GREATERTHAN:
        operatorToken = jj_consume_token(GREATERTHAN);
        break;
      case GREATEROREQUAL:
        operatorToken = jj_consume_token(GREATEROREQUAL);
        break;
      case LESSOREQUAL:
        operatorToken = jj_consume_token(LESSOREQUAL);
        break;
      case EQUAL:
        operatorToken = jj_consume_token(EQUAL);
        break;
      case NOTEQUAL:
        operatorToken = jj_consume_token(NOTEQUAL);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = expressionCHILL();
            // create operation expression from left and right
            ASTOperatorExpression newOpExp = new ASTOperatorExpression(left, right, operatorToken.toString(), operatorToken.beginLine);
            // set left to be the new operation expression          
            left = newOpExp;
    }
        {if (true) return left;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expressionCHILL() throws ParseException {
    ASTExpression left = null;
    ASTExpression right = null;

    Token operatorToken = null;
    left = termCHILL();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        operatorToken = jj_consume_token(MINUS);
        break;
      case PLUS:
        operatorToken = jj_consume_token(PLUS);
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = termCHILL();
            // create operation expression from left and right
            ASTOperatorExpression newOpExp = new ASTOperatorExpression(left, right, operatorToken.toString(), operatorToken.beginLine);
            // set left to be the new operation expression          
            left = newOpExp;
    }
        {if (true) return left;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression termCHILL() throws ParseException {
    ASTExpression left = null;
    ASTExpression right = null;
    Token operatorToken = null;
    Token notToken = null;
    Token notToken2 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      notToken = jj_consume_token(NOT);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    left = factor();
        if(notToken != null) {
            left = new ASTUnaryOperatorExpression(left, notToken.toString(), notToken.beginLine);
        }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        operatorToken = jj_consume_token(MULTIPLY);
        break;
      case DIVIDE:
        operatorToken = jj_consume_token(DIVIDE);
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        notToken2 = jj_consume_token(NOT);
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      right = factor();
            if(notToken2 != null) {
            System.out.println("B:" + notToken2.beginLine);
                right = new ASTUnaryOperatorExpression(right, notToken2.toString(), notToken2.beginLine);
            }

            // create operation expression from left and right
            ASTOperatorExpression newOpExp = new ASTOperatorExpression(left, right, operatorToken.toString(), operatorToken.beginLine);
            // set left to be the new operation expression          
            left = newOpExp;
    }
        {if (true) return left;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression factor() throws ParseException {
    ASTExpression exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTPARAN:
      jj_consume_token(LEFTPARAN);
      exp = expressionTopTopCHILL();
      jj_consume_token(RIGHTPARAN);
      break;
    case TRUE:
    case FALSE:
    case MINUS:
    case SINGLEQUOTE:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      exp = expressionVarOrConstant();
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expNoNewNoParans() throws ParseException {
    ASTExpression left;
    ASTExpression right = null;
    Token operator = null;
    left = expressionVarOrConstant();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case MULTIPLY:
    case DIVIDE:
    case EQUAL:
    case GREATERTHAN:
    case NOT:
    case GREATEROREQUAL:
    case AND:
    case NOTEQUAL:
    case LESSOREQUAL:
    case LESSTHAN:
    case OR:
      operator = expressionOperator();
      right = expNoNew();
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
        if(right==null) {
            {if (true) return left;}
        } else {
            {if (true) return new ASTOperatorExpression(left, right, operator.toString(), operator.beginLine);}
        }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expressionVarOrConstant() throws ParseException {
    ASTExpression resultingExpression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      resultingExpression = expressionVar();
      break;
    case TRUE:
    case FALSE:
    case MINUS:
    case SINGLEQUOTE:
    case INTEGER_LITERAL:
      resultingExpression = expressionConstant();
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return resultingExpression;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expressionVar() throws ParseException {
    Token base;
    ASTVariable baseVar;
    ASTFunctionCallExpression functionCall = null;
    base = jj_consume_token(IDENTIFIER);
        // initialize baseVar for propertAccessor recursion
        baseVar = new ASTBaseVariable(base.toString(), base.beginLine);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTBRACKET:
    case DOT:
      baseVar = propertyAccessors(baseVar);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTPARAN:
      functionCall = expInformalParamList(base);
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
        if(functionCall != null) {
            {if (true) return functionCall;}
        } else {
            {if (true) return new ASTVariableExpression(baseVar, base.beginLine);}
        }
    throw new Error("Missing return statement in function");
  }

  static final public void classExpVar() throws ParseException {
    Token classVar;
    jj_consume_token(DOT);
    classVar = jj_consume_token(IDENTIFIER);
  }

/* Parses primitives */
  static final public ASTExpression expressionConstant() throws ParseException {
    Token boolVal;
    boolean isNegative = false;
    Token intLiteral;
    Token charVal;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SINGLEQUOTE:
      jj_consume_token(SINGLEQUOTE);
      charVal = jj_consume_token(IDENTIFIER);
      jj_consume_token(SINGLEQUOTE);
        if (charVal.toString().length() > 0) {
            {if (true) return new ASTCharLiteral(charVal.toString().charAt(0), charVal.beginLine);}
        } else {
            {if (true) return new ASTCharLiteral('\u005c0', charVal.beginLine);}
        }
      break;
    case TRUE:
    case FALSE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
        boolVal = jj_consume_token(TRUE);
        break;
      case FALSE:
        boolVal = jj_consume_token(FALSE);
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        /* Boolean Literal was parsed. */

        // convert String value of token to boolean
        boolean actualValue;
        if(boolVal.toString().compareTo("true") == 0) {
            actualValue = true;
        } else {
            actualValue = false;
        }

        {if (true) return new ASTBooleanLiteral(actualValue, boolVal.beginLine);}
      break;
    case MINUS:
    case INTEGER_LITERAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        jj_consume_token(MINUS);
          isNegative = true;
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      intLiteral = jj_consume_token(INTEGER_LITERAL);
        int actualIntValue = Integer.parseInt(intLiteral.toString());
        if(isNegative) {
            {if (true) return new ASTOperatorExpression( new ASTIntegerLiteral(0, intLiteral.beginLine), new ASTIntegerLiteral(actualIntValue, intLiteral.beginLine), "-", intLiteral.beginLine);}
        }
        {if (true) return new ASTIntegerLiteral(actualIntValue, intLiteral.beginLine);}
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTFunctionCallExpression expInformalParamList(Token base) throws ParseException {
    ASTExpression formal = null;
    ASTFunctionCallExpression functionCall = new ASTFunctionCallExpression(base.toString(), base.beginLine);
    jj_consume_token(LEFTPARAN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case NEW:
    case MINUS:
    case NOT:
    case LEFTPARAN:
    case SINGLEQUOTE:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      formal = expression();
            functionCall.addElement(formal);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[52] = jj_gen;
          break label_15;
        }
        jj_consume_token(COMMA);
        formal = expression();
                functionCall.addElement(formal);
      }
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    jj_consume_token(RIGHTPARAN);
        {if (true) return functionCall;}
    throw new Error("Missing return statement in function");
  }

  static final public Token expressionOperator() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      t = jj_consume_token(PLUS);
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
      break;
    case MULTIPLY:
      t = jj_consume_token(MULTIPLY);
      break;
    case DIVIDE:
      t = jj_consume_token(DIVIDE);
      break;
    case GREATERTHAN:
      t = jj_consume_token(GREATERTHAN);
      break;
    case LESSTHAN:
      t = jj_consume_token(LESSTHAN);
      break;
    case LESSOREQUAL:
      t = jj_consume_token(LESSOREQUAL);
      break;
    case GREATEROREQUAL:
      t = jj_consume_token(GREATEROREQUAL);
      break;
    case EQUAL:
      t = jj_consume_token(EQUAL);
      break;
    case NOTEQUAL:
      t = jj_consume_token(NOTEQUAL);
      break;
    case AND:
      t = jj_consume_token(AND);
      break;
    case OR:
      t = jj_consume_token(OR);
      break;
    case NOT:
      t = jj_consume_token(NOT);
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public simplejavaTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[55];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x4000,0x0,0x0,0x4021e00,0x4000000,0x40000000,0x0,0x40000000,0x2158000,0x8000000,0x20000,0x20000,0x4021e00,0x28000000,0x28000000,0x28000000,0x28000000,0x180000,0x0,0x40000000,0x2158000,0x28180000,0x180000,0x4021e00,0x2158000,0x2000,0x0,0x0,0x2158000,0x8000000,0x8000000,0x2158000,0x83f80000,0x83f80000,0x0,0x0,0x81800000,0x81800000,0x180000,0x180000,0x2000000,0x600000,0x600000,0x2000000,0x118000,0x83f80000,0x118000,0x28000000,0x0,0x18000,0x100000,0x118000,0x40000000,0x2158000,0x83f80000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x2000,0x2000,0x2001,0x1,0x0,0x2000,0x0,0x3408,0x0,0x2000,0x2000,0x2001,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x3408,0x2108,0x0,0x2001,0x3408,0x0,0x2000,0x2000,0x3408,0x0,0x8,0x3408,0x2e2,0x2e2,0x202,0x202,0xe0,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x3408,0x2e2,0x3400,0x0,0x8,0x0,0x0,0x1400,0x0,0x3408,0x2e2,};
   }

  /** Constructor with InputStream. */
  public simplejava(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public simplejava(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new simplejavaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public simplejava(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new simplejavaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public simplejava(simplejavaTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(simplejavaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[46];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 55; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 46; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
